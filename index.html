<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Programowanie Obiektowe w Pythonie</title>

	<meta name="description" content="PO LAB python">
	<meta name="author" content="Norbert Waszkowiak">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css" id="theme">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
	<style>
		.row {
			display: flex;
		}

		.column {
			flex: 50%;
			padding: 10px;
		}
	</style>
	<style>
		.small-font pre {
			font-size: 13px;
			/* Zmniejszenie czcionki */
			margin-left: 0;
			/* Usunięcie marginesu z lewej strony */
			white-space: pre-wrap;
			/* Zapobieganie przepełnieniu tekstu */
		}
	</style>

</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">


			<section data-background-gradient="linear-gradient(45deg, #33, #6754e8)">
				<h1>Programowanie obiektowe w Pythonie</h1>
			</section>

			<section data-background-gradient="linear-gradient(45deg, #33, #6754e8)">
				<h2>Wszystko jest obiektem</h2>
				<p>
					Programowanie obiektowe (OOP) to paradygmat programowania, który opiera się na koncepcji "obiektów"
					- strukturze, która
					zawiera dane w postaci pól, znane również jako atrybuty, oraz kod w postaci procedur, znanych jako
					metody. W Pythonie
					wszystko jest obiektem!
				</p>
			</section>
			<section>
				<h2>Podstawowe koncepcje</h2>
				<section>
					<p>Klasy i obiekty</p>
					<small>Klasa to szablon do tworzenia obiektów.</small>
					<small>Obiekt to instancja klasy, posiadająca unikalne atrybuty i metody.</small>
					<pre><code data-trim class="python">class Samochod:
		def __init__(self, marka, model):
				self.marka = marka
				self.model = model

samochod1 = Samochod("Toyota", "Camry")
</code></pre>
					<small>
						<b>self</b> wskazuje na instancję obiektu, na którym metoda jest wywoływana. Jest to sposób, aby
						metoda wiedziała, na którym
						konkretnym obiekcie operuje. Kiedy wywoływana jest metoda na instancji klasy, Python
						automatycznie przekazuje tę instancję
						jako pierwszy argument do metody. W tym przypadku nazwa <b>self</b> jest tylko konwencją, a nie
						wymogiem.
					</small>
				</section>
				
				<section>
					<h3>Więcej o klasach i obiektach</h3>
					<ul>
						<li><b>Klasa</b> definiuje strukturę i zachowanie obiektów – określa, jakie atrybuty i metody będą miały jej instancje.</li>
						<li><b>Obiekt</b> to konkretny egzemplarz klasy, posiadający własne wartości atrybutów.</li>
						<li>Można utworzyć wiele obiektów tej samej klasy, każdy z własnym stanem.</li>
						<li>Metoda <b>__init__</b> to tzw. konstruktor – jest wywoływana automatycznie podczas tworzenia obiektu.</li>
						<li>Obiekty mogą być przekazywane jako argumenty do funkcji, zwracane z funkcji i przechowywane w strukturach danych.</li>
					</ul>
					<pre><code data-trim class="python">class Student:
		def __init__(self, imie, nr_indeksu):
				self.imie = imie
				self.nr_indeksu = nr_indeksu

student1 = Student("Anna", 12345)
student2 = Student("Jan", 67890)

print(student1.imie)  # Anna
print(student2.nr_indeksu)  # 67890
</code></pre>
					<small>
						Każdy obiekt <b>Student</b> ma własne wartości atrybutów <b>imie</b> i <b>nr_indeksu</b>. Dzięki temu można łatwo reprezentować wiele różnych studentów w programie.
					</small>
				</section>
				<section>
					<p>Atrybuty i metody</p>
					<small>Atrybuty to zmienne przypisane do obiektu.</small>
					<small>Metody to funkcje związane z obiektem.</small>
					<pre><code data-trim class="python">class Kalkulator:
		wynik = 0
						
		def dodaj(self, x):
				self.wynik += y
				return self.wynik

kalk = Kalkulator()
wynik = kalk.dodaj(3)
								</code></pre>
				</section>
			</section>
			<section>
				<h2>Dziedziczenie</h2>
				<section>
					<p>Tworzenie nowej klasy na podstawie istniejącej.</p>
					<pre><code data-trim class="python">class Pojazd:
        def ruszaj(self):
                print("Pojazd rusza.")

class Samochod(Pojazd):
        def zatrzymaj(self):
                print("Samochód zatrzymuje się.")
    </code></pre>
				</section>
				<section>
                    <h3>Czym jest dziedziczenie?</h3>
                    <ul>
                        <li>Pozwala tworzyć nowe klasy na podstawie już istniejących (klas bazowych).</li>
                        <li>Nowa klasa (pochodna) dziedziczy atrybuty i metody klasy bazowej.</li>
                        <li>Umożliwia ponowne wykorzystanie kodu i łatwiejsze zarządzanie złożonymi systemami.</li>
                        <li>Klasa pochodna może rozszerzać lub modyfikować zachowanie klasy bazowej.</li>
                    </ul>
                    <pre><code data-trim class="python">class Zwierze:
        def daj_glos(self):
                print("To jest ogólny dźwięk zwierzęcia.")

class Pies(Zwierze):
        def daj_glos(self):
                print("Hau hau!")
pies = Pies()
pies.daj_glos()  # Hau hau!
</code></pre>
                </section>
                <section>
                    <h3>super() i rozszerzanie funkcjonalności</h3>
                    <ul>
                        <li>Funkcja <b>super()</b> pozwala odwołać się do metod klasy bazowej.</li>
                        <li>Umożliwia wywołanie oryginalnej implementacji i jej rozszerzenie.</li>
                    </ul>
                    <pre><code data-trim class="python">class Pracownik:
        def __init__(self, imie):
                self.imie = imie

class Programista(Pracownik):
        def __init__(self, imie, jezyk):
                super().__init__(imie)
                self.jezyk = jezyk

p = Programista("Ola", "Python")
print(p.imie)   # Ola
print(p.jezyk)  # Python
</code></pre>
                    <small>
                        <b>super().__init__(imie)</b> wywołuje konstruktor klasy bazowej, dzięki czemu nie trzeba powielać kodu inicjalizującego.
                    </small>
                </section>
				<section>
					<p>Dziedziczenie wielkrotne.</p>
					<pre><code data-trim class="python">class PierwszaKlasaNadrzedna:
		def metoda_pierwsza(self):
			print("To jest metoda z pierwszej klasy nadrzędnej.")
					
class DrugaKlasaNadrzedna:
		def metoda_druga(self):
			print("To jest metoda z drugiej klasy nadrzędnej.")
					
class KlasaPotomna(PierwszaKlasaNadrzedna, DrugaKlasaNadrzedna):
		def metoda_potomna(self):
				print("To jest metoda z klasy potomnej.")
					
# Użycie klasy potomnej
obiekt_potomny = KlasaPotomna()
obiekt_potomny.metoda_pierwsza() # Dziedziczone z PierwszaKlasaNadrzedna
obiekt_potomny.metoda_druga() # Dziedziczone z DrugaKlasaNadrzedna
obiekt_potomny.metoda_potomna() # Lokalna metoda z KlasaPotomna
</code></pre>
				</section>




				<section>
					<p>Przesłanianie metod</p>
					<pre><code data-trim class="python">class Kolo:
		def info(self):
				print("To jest kółko.")
						
class KoloKolorowe(Kolo):
		def info(self):
				print("To jest kolorowe kółko.")
					</code></pre>
				</section>

			</section>

			<section>
				<h2>Polimorfizm</h2>
				<section>
					<p>Przeładowywanie operatorów</p>
					<pre><code data-trim class="python">class Punkt:
		def __init__(self, x, y):
				self.x = x
				self.y = y
					
		def __add__(self, other):
				return Punkt(self.x + other.x, self.y + other.y)
a = Punkt(1,2)
b = Punkt(3,4)
c = a + b
</code></pre>
				</section>
				<section>
                    <h3>Czym jest polimorfizm?</h3>
                    <ul>
                        <li>Pozwala używać tych samych metod lub interfejsów dla różnych typów obiektów.</li>
                        <li>Obiekty różnych klas mogą być traktowane w ten sam sposób, jeśli implementują te same metody.</li>
                        <li>Ułatwia rozszerzanie i modyfikowanie kodu bez konieczności zmiany istniejących funkcji.</li>
                    </ul>
                    <pre><code data-trim class="python">class Zwierze:
        def daj_glos(self):
                print("Zwierzę wydaje dźwięk.")

class Pies(Zwierze):
        def daj_glos(self):
                print("Hau hau!")

class Kot(Zwierze):
        def daj_glos(self):
                print("Miau!")

def wydaj_dzwiek(zwierze):
        zwierze.daj_glos()

wydaj_dzwiek(Pies())  # Hau hau!
wydaj_dzwiek(Kot())   # Miau!
</code></pre>
                    <small>
                        Funkcja <b>wydaj_dzwiek</b> działa poprawnie dla każdego obiektu, który posiada metodę <b>daj_glos</b>, niezależnie od jego klasy.
                    </small>
                </section>
                <section>
                    <h3>Polimorfizm w praktyce</h3>
                    <ul>
                        <li>Polimorfizm umożliwia tworzenie uniwersalnych funkcji i struktur danych.</li>
                        <li>Przykład: lista różnych obiektów i wywołanie tej samej metody na każdym z nich.</li>
                    </ul>
                    <pre><code data-trim class="python">class Kaczka:
        def plywaj(self):
                print("Kaczka pływa.")

class Lódz:
        def plywaj(self):
                print("Łódź płynie.")

obiekty = [Kaczka(), Lódz()]

for obiekt in obiekty:
        obiekt.plywaj()
# Wynik:
# Kaczka pływa.
# Łódź płynie.
</code></pre>
                    <small>
                        Każdy obiekt w liście <b>obiekty</b> posiada metodę <b>plywaj</b>, więc można je obsłużyć w ten sam sposób, mimo że należą do różnych klas.
                    </small>
                </section>
                <section>
                    <h3>Wywołanie obiektu jak funkcji</h3>
                    <pre><code data-trim class="python">class Licznik:
		def __init__(self):
				self.liczba = 0

		def __call__(self):
				self.liczba += 1
				return self.liczba

# Użycie obiektu jak funkcji
licznik = Licznik()
print(licznik()) # Wywołanie obiektu jak funkcji
print(licznik()) # Ponowne wywołanie

</code></pre>
				</section>
			</section>
			<section>
				<h2>Hermetyzacja</h2>
				<section>
					<p>Ukrywanie danych</p>
					<small>Publiczne, chronione i prywatne atrybuty.</small>
					<pre><code data-trim class="python">class KontoBankowe:
        def __init__(self, saldo):
                self._saldo = saldo # chroniony
                self.__haslo = "tajne" # prywatny
</code></pre>
				</section>
				<section>
                    <h3>Poziomy dostępu do atrybutów</h3>
                    <ul>
                        <li><b>Publiczne</b> (np. <code>self.imie</code>): dostępne z każdego miejsca.</li>
                        <li><b>Chronione</b> (np. <code>self._saldo</code>): konwencja, że nie powinny być używane poza klasą i jej podklasami.</li>
                        <li><b>Prywatne</b> (np. <code>self.__haslo</code>): Python stosuje tzw. name mangling, utrudniając dostęp spoza klasy.</li>
                    </ul>
                    <pre><code data-trim class="python">class Przyklad:
        def __init__(self):
                self.publiczny = 1
                self._chroniony = 2
                self.__prywatny = 3

obiekt = Przyklad()
print(obiekt.publiczny)    # 1
print(obiekt._chroniony)   # 2 (można, ale niezalecane)
# print(obiekt.__prywatny) # Błąd!
print(obiekt._Przyklad__prywatny) # 3 (name mangling)
</code></pre>
                    <small>
                        Python nie wymusza ścisłej ochrony, ale stosuje konwencje i mechanizm name mangling dla prywatnych atrybutów.
                    </small>
                </section>
                <section>
                    <h3>Hermetyzacja z użyciem getterów i setterów</h3>
                    <ul>
                        <li>Hermetyzacja pozwala kontrolować dostęp do atrybutów za pomocą metod typu getter i setter.</li>
                        <li>W Pythonie można użyć dekoratora <code>@property</code> do tworzenia właściwości.</li>
                    </ul>
                    <pre><code data-trim class="python">class Osoba:
        def __init__(self, wiek):
                self._wiek = wiek

        @property
        def wiek(self):
                return self._wiek

        @wiek.setter
        def wiek(self, nowy_wiek):
                if nowy_wiek >= 0:
                        self._wiek = nowy_wiek
                else:
                        raise ValueError("Wiek nie może być ujemny.")

os = Osoba(25)
print(os.wiek)   # 25
os.wiek = 30     # setter
</code></pre>
                    <small>
                        Dzięki <b>@property</b> można bezpiecznie udostępniać atrybuty i kontrolować ich modyfikację.
                    </small>
                </section>
				<section>
					<p>Manglingu</p>
					<small>Mechanizm manglingu polega na dodaniu przed nazwą metody prefiksu z nazwą klasy, co sprawia,
						że staje się trudniejsze,
						ale nie niemożliwe, dostęp do tych metod z zewnątrz klasy.</small>
					<pre><code data-trim class="python">class KlasaPrzykladowa:
		def __init__(self):
				self.__prywatna_metoda()

		def __prywatna_metoda(self):
				print("To jest prywatna metoda.")

# Utworzenie obiektu klasy
obiekt = KlasaPrzykladowa()

# Próba dostępu do prywatnej metody z zewnątrz klasy
# To jest technicznie możliwe, ale zwykle nie jest zalecane.
obiekt._KlasaPrzykladowa__prywatna_metoda()
					</code></pre>
				</section>
				<section>
					<p>Dekoratory w Pythonie</p>
					<pre style="font-size: 16px;"><code  data-trim class="python">class Osoba:
		def __init__(self, imie, nazwisko):
				self.imie = imie
				self.nazwisko = nazwisko

		@property
		def pelne_nazwisko(self):
				return f"{self.imie} {self.nazwisko}"
</code></pre>
					<small>
						<ul>
							<li>
								W języku Python dekorator to specjalny rodzaj funkcji, która umożliwia modyfikację
								funkcji lub
								metody, do której jest
								przypisana. Dekoratory są używane do "ozdabiania" funkcji, dodawania dodatkowej
								funkcjonalności
								lub modyfikowania jej
								działania bez zmiany samej funkcji.
							</li>
							<li>Wbudowane dekoratory to np. @staticmethod, @classmethod czy
								@property.</li>
							<li>Programiści mogą także tworzyć własne dekoratory w zależności od
								potrzeb.</li>
							<li>@property który umożliwia definiowanie tzw. właściwości
								(properties) dla klas.
								Właściwości pozwalają na dostęp do atrybutów obiektu tak, jakby były atrybutami klasy,
								jednocześnie umożliwiając
								bardziej zaawansowane operacje przy odczycie i zapisie wartości.</li>
						</ul>

					</small>
					<small>

					</small>
				</section>
			</section>

			<section>
				<h2>Przykład</h2>
				<pre><code data-trim class="python">class Zwierze:
		def __init__(self, imie):
				self.imie = imie

		def przedstaw_sie(self):
				pass

class Pies(Zwierze):
		def przedstaw_sie(self):
				print(f"Jestem psem o imieniu {self.imie}.")

class Kot(Zwierze):
		def przedstaw_sie(self):
				print(f"Jestem kotem o imieniu {self.imie}.")

</code></pre>
				<small>W tym przykładzie utworzono klasy <b>Zwierze</b>, <b>Pies</b> i <b>Kot</b>, demonstrując
					polimorfizm poprzez przesłanianie metody
					<b>przedstaw_sie</b>.</small>


			</section>
			<section>
				<h2>Abstrakcja w pythonie</h2>
				<section>
                                    <small>W Pythonie, moduł abc (Abstract Base Classes) dostarcza mechanizmów do tworzenia klas abstrakcyjnych i metod
                                        abstrakcyjnych. Klasa abstrakcyjna to klasa, która nie może być instancjonowana bezpośrednio, a metoda abstrakcyjna
                                        to
                                        metoda, która jest deklarowana, ale nie ma implementacji w samej klasie. Klasy dziedziczące po klasie abstrakcyjnej
                                        muszą dostarczyć implementację dla wszystkich jej metod abstrakcyjnych.</small>
                </section>
                <section>
                    <h3>Czym jest abstrakcja?</h3>
                    <ul>
                        <li>Abstrakcja pozwala ukryć szczegóły implementacyjne i pokazać tylko istotne cechy obiektu.</li>
                        <li>W Pythonie realizowana jest przez klasy i metody abstrakcyjne (moduł <code>abc</code>).</li>
                        <li>Klasa abstrakcyjna definiuje interfejs, który muszą zaimplementować klasy pochodne.</li>
                        <li>Nie można utworzyć instancji klasy abstrakcyjnej – służy ona jako szablon.</li>
                    </ul>
                    <pre><code data-trim class="python">from abc import ABC, abstractmethod

class Zwierze(ABC):
    @abstractmethod
    def daj_glos(self):
        pass

# zw = Zwierze()  # TypeError: Can't instantiate abstract class
</code></pre>
                    <small>
                        Klasa <b>Zwierze</b> jest abstrakcyjna – nie można utworzyć jej instancji, dopóki nie zostaną zaimplementowane wszystkie metody abstrakcyjne.
                    </small>
                </section>
                <section>
                    <h3>Praktyczne zastosowanie abstrakcji</h3>
                    <ul>
                        <li>Abstrakcja ułatwia projektowanie dużych systemów – pozwala skupić się na interfejsie, a nie szczegółach implementacji.</li>
                        <li>Klasy pochodne muszą zaimplementować wszystkie metody oznaczone jako <code>@abstractmethod</code>.</li>
                    </ul>
                    <pre><code data-trim class="python">from abc import ABC, abstractmethod

class Narzedzie(ABC):
    @abstractmethod
    def uzyj(self):
        pass

class Mlotek(Narzedzie):
    def uzyj(self):
        print("Uderzanie młotkiem.")

class Srubokret(Narzedzie):
    def uzyj(self):
        print("Wkręcanie śrubokrętem.")

def testuj_narzedzie(narzedzie):
    narzedzie.uzyj()

testuj_narzedzie(Mlotek())
testuj_narzedzie(Srubokret())
</code></pre>
                    <small>
                        Funkcja <b>testuj_narzedzie</b> działa dla każdego narzędzia, które implementuje metodę <b>uzyj</b>, niezależnie od szczegółów działania.
                    </small>
                </section>
                <section>
                    <pre style="font-size: 14px"><code style="max-height: 350px;" data-trim class="python">from abc import ABC, abstractmethod
                    
class FiguraGeometryczna(ABC):
        @abstractmethod
        def oblicz_powierzchnie(self):
                pass

class Kolo(FiguraGeometryczna):
        def __init__(self, promien):
                self.promien = promien

        def oblicz_powierzchnie(self):
                return 3.14 * self.promien ** 2

class Prostokat(FiguraGeometryczna):
        def __init__(self, dlugosc, szerokosc):
                self.dlugosc = dlugosc
                self.szerokosc = szerokosc

        def oblicz_powierzchnie(self):
                return self.dlugosc * self.szerokosc

# Przykład użycia
kolo = Kolo(5)
print(f"Powierzchnia koła: {kolo.oblicz_powierzchnie()}")

prostokat = Prostokat(4, 6)
print(f"Powierzchnia prostokąta: {prostokat.oblicz_powierzchnie()}")
                    </code></pre>
                    <small>
                        W tym przykładzie <b>FiguraGeometryczna</b> to klasa abstrakcyjna, która posiada jedną metodę abstrakcyjną
                        <b>oblicz_powierzchnie()</b>. Klasy <b>Kolo</b> i <b>Prostokat</b> dziedziczą po tej klasie abstrakcyjnej i
                        dostarczają implementację metody
                        <b>oblicz_powierzchnie()</b>.
                    
                        Jeśli klasa dziedzicząca nie dostarczy implementacji metody abstrakcyjnej, Python wygeneruje błąd <b>TypeError</b>
                        podczas
                        próby instancjonowania tej klasy.
                    </small>

                </section>
<!--
